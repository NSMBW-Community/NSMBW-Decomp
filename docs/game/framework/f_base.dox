/*!
@class fBase_c
@details
## Overview
fBase_c defines the core elements of a process, to provide common behaviour across all bases.

The most significant components are:
- #mUniqueID, a unique identifier for every created base.
- #mParam, a 32-bit value used to configure the base. For profiles representing level sprites, this
field is equivalent to nybbles 5 to 12 of Reggie' sprite data. Classes that don't represent a specific
profile should avoid using this value to determine their behaviour.
- #mProfName, an identifier for the base's profile.
- #mGroupType, which specifies the base's group type (see
[Inheritance and Group Types](#inheritance-and-group-types) for more details).
- The class embeds @ref mMng "an instance of fManager_c", which manages most of the base's lifecycle.
- The remaining fields are also related to the base's lifecycle or are entirely unused.

## Creating Bases
A base can be created by calling the createRoot() or the createChild() functions. Most subclasses
provide their own implementations of these functions with additional parameters available; their use
is recommended.

The overloaded @ref operator new() "new" operator ensures that bases are zero-initialized (therefore
initializing fields to zero is not necessary), while the @ref operator delete() "delete" operator is
provided for convenience.

## Deleting Bases
Bases can be deleted by calling deleteRequest() on them. A base will be informed of its impending
deletion when its deleteReady() method is called. Please note that deleting a base will delete all
its children as well.

## Iterating Bases
A small iteration API is provided:
- Use getConnectParent() to get a base's parent.
- Use getConnectChild() to get a base's first child.
- Use getConnectBrNext() to get a base's next sibling.

For conducting searches across the entire base tree, please refer to
@xlink{./classfManager__c.html#global-base-searching, fManager_c}.

## Inheritance and Group Types
The #mGroupType field offers basic type information about a base:
- Bases with group type #OTHER are generic processes, which inherit from dBase_c.
- Bases with group type #SCENE are scene profiles, which inherit from dScene_c.
- Bases with group type #ACTOR are game entities, which inherit from dBaseActor_c.

No base inherits fBase_c directly.

## Base Lifecycle
The lifecycle of a base consists of multiple operations, whose behaviour can be overridden by any of the
subclasses. Each operation has an @xlink{./classfManager__c.html#implementation, associated linked list},
containing all bases for which said operation is scheduled for the current frame. fBase_c (and
fManager_c) manage operation scheduling internally, therefore developer interaction is not required.

### Operation Flow
Every operation is composed by three steps: @p pre , @p do and @p post (each with their own methods).
While the @p do method is generally reserved for profile-specific behaviour, the @p pre and @p post
methods are commonly used to supply shared behaviour in base classes.

The @p pre and @p do steps return a PACK_RESULT_e value, which is converted to a MAIN_STATE_e
value to determine the result of the operation. Said value is then passed to the @p post method,
which acts accordingly.
@p pre step result | @p do step result | @p post argument
:-----------------: | :----------------: | :--------------:
#NOT_READY | *N/A (not run)* | #CANCELED
#SUCCEEDED | #NOT_READY | #WAITING
#SUCCEEDED | #SUCCEEDED | #SUCCESS
#SUCCEEDED | #FAILED | #ERROR
Operations are carried out by the commonPack() function.

### Core Operations
fBase_c defines four core operations:
- @p create runs immediately after construction, and can be used to set up the base or load resources
for it. The operation result leads to three possible outcomes:
 - If the operation result is #SUCCESS, the base enters the main execution cycle.
 - If the operation result is #CANCELED or #WAITING, the operation will be reattempted in the next frame.
 - If the operation result is #ERROR, the base is deleted.

- @p execute serves as the base's own main loop, running every frame. This operation can be skipped by
enabling the relevant PROC_DISABLE_e flag.
- @p draw offers an alternative main loop specifically for rendering code. It also runs every frame,
and can be skipped by enabling the relevant PROC_DISABLE_e flag.
- @p delete runs immediately before destruction, and can be used to deallocate resources or remove
links to other bases. This operation will not proceed until all the base's children are deleted.

@inlineimage fBase_lifecycle.svg
@imagecaption{The lifecycle of a base.}

### Connect Operation
@p connect is an internal operation for process management that runs every frame along the
aforementioned four; bases should not override it. See connectProc() for more information on the tasks
carried out in this operation.

## Unused Content
- #sLoadAsyncCallback and #sUnloadCallback are presumably related to the scrapped relocatable
profile system (more details here). These callbacks are set to empty placeholder functions (which belong
to dBase_c) by dBase_c::initLoader. Judging by their names, they were supposed to be called after a
profile module would have been loaded/unloaded.
- Each base supports having its own @ref mHeap "heap". The heap name, translated from Japanese,
is *Heap that each process can have individually (fBase_c::mHeap)*. Two working methods for creating
this heap are still in the game (entryFrmHeap(), entryFrmHeapNonAdjust()), but are unused. This per-base
allocation method was most likely discontinued in favour of mAllocator_c and its derivatives.
- Two additional unused list-like structures are present in the class: #mpUnusedHelper and
#mUnusedList. Since the symbols for the related functions have not yet been cracked, it's difficult
to tell what their purpose might have been.

@todo Link to unused relocation system article and mAllocator_c when their page gets written.
*/
